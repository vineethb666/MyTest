{"took":12,"timed_out":false,"_shards":{"total":1,"successful":1,"skipped":0,"failed":0},"hits":{"total":{"value":1322,"relation":"eq"},"max_score":3.3886242,"hits":[{"_index":"docs","_type":"page","_id":"92380584a887ede2634accc40ed1d072","_score":3.3886242,"_source":{"id":"92380584a887ede2634accc40ed1d072","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:585","title":"Learning Python.txt","headers":"","content":"first = True\r\nfor arg in args:\r\noutput += ('' if first else sep) + str(arg)\r\nfirst = False\r\nfile.write(output + end)\r\n\r\nThis version works the same as the original, and it’s a prime example of how keywordonly arguments come in handy. The original version assumes that all positional arguments are to be printed, and all keywords are for options only. That’s almost sufficient,\r\nbut any extra keyword arguments are silently ignored. A call like the following, for\r\ninstance, will generate an exception correctly with the keyword-only form:\r\n>>> print3(99, name='bob')\r\nTypeError: print3() got an unexpected keyword argument 'name'\r\n\r\nbut will silently ignore the name argument in the original version. To detect superfluous\r\nkeywords manually, we could use dict.pop() to delete fetched entries, and check if the\r\ndictionary is not empty. The following version, in the file print3_alt2.py, is equivalent\r\nto the keyword-only version—it triggers a built-in exception with a raise statement,\r\nwhich works just as though Python had done so (we’ll study this in more detail in\r\nPart VII):\r\n#!python\r\n\"Use 2.X/3.X keyword args deletion with defaults\"\r\nimport sys\r\ndef print3(*args, **kargs):\r\nsep = kargs.pop('sep', ' ')\r\nend = kargs.pop('end', '\\n')\r\nfile = kargs.pop('file', sys.stdout)\r\nif kargs: raise TypeError('extra keywords: %s' % kargs)\r\noutput = ''\r\nfirst = True\r\nfor arg in args:\r\noutput += ('' if first else sep) + str(arg)\r\nfirst = False\r\nfile.write(output + end)\r\n\r\nThis works as before, but it now catches extraneous keyword arguments, too:\r\n>>> print3(99, name='bob')\r\nTypeError: extra keywords: {'name': 'bob'}\r\n\r\nThis version of the function runs under Python 2.X, but it requires four more lines of\r\ncode than the keyword-only version. Unfortunately, the extra code is unavoidable in\r\nthis case—the keyword-only version works on 3.X only, which negates most of the\r\nreason that I wrote this example in the first place: a 3.X emulator that only works on\r\n3.X isn’t incredibly useful! In programs written to run on 3.X only, though, keywordonly arguments can simplify a specific category of functions that accept both arguments\r\nand options. For another example of 3.X keyword-only arguments, be sure to see the\r\niteration timing case study in Chapter 21.\r\n\r\nEmulating the Python 3.X print Function | 549"}},{"_index":"docs","_type":"page","_id":"28305abeb32a28cf384d3ce7c30542e8","_score":3.346646,"_source":{"id":"28305abeb32a28cf384d3ce7c30542e8","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1460","title":"Learning Python.txt","headers":"","content":"#! python3\r\nimport sys\r\nprint(sys.version.split()[0])\r\nC:\\code> what.py\r\n3.3.0\r\n\r\n# Run per file directive\r\n\r\nC:\\code> py what.py\r\n3.3.0\r\n\r\n# Ditto: latest 3.X\r\n\r\nAgain, the space after #! is optional; I added a space to demonstrate the point here.\r\nNote that the first what.py command here is equivalent to both an icon click and a full\r\npy what.py, because the py.exe program is registered to open .py files automatically in\r\nthe Windows filename associations registry when the launcher is installed.\r\nAlso note that when launcher documentation (including this appendix) talks about the\r\nlatest version, it means the highest-numbered version. That is, it refers to the latest\r\nreleased, not the latest installed on your computer (e.g., if you install 3.1 after 3.3, #!\r\npython3 selects the latter). The launcher cycles through the Pythons on your computer\r\nto find the highest-numbered version that matches your specification or defaults; this\r\ndiffers from the former last-installed-wins model.\r\nNow, changing the first line name to python2 triggers the latest (really, highest-numbered) 2.X installed instead. Here’s this change at work; I’ll omit the last two lines of\r\nour script from this point on because they won’t be altered:\r\n#! python2\r\n...rest of script unchanged\r\nC:\\code> what.py\r\n2.7.3\r\n\r\n# Run with latest 2.X per #!\r\n\r\nAnd you can request a more specific version if needed—for example, if you don’t want\r\nthe latest in a Python line:\r\n#! python3.1\r\n...\r\nC:\\code> what.py\r\n3.1.4\r\n\r\n# Run with 3.1 per #!\r\n\r\nThis is true even if the requested version is not installed—which is treated as an error\r\ncase by the launcher:\r\n#! python2.6\r\n...\r\nC:\\code> what.py\r\nRequested Python version (2.6) is not installed\r\n\r\nUnrecognized Unix #! lines are also treated as errors, unless you give a version number\r\nas a command-line switch to compensate, as the next section describes in more detail\r\n(and as the section on launcher issues will revisit as a pitfall):\r\n\r\n1442 | Appendix B: The Python 3.3 Windows Launcher"}},{"_index":"docs","_type":"page","_id":"bfdfe4bc31e43c2bd9eebccf32c3207b","_score":3.3274891,"_source":{"id":"bfdfe4bc31e43c2bd9eebccf32c3207b","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1463","title":"Learning Python.txt","headers":"","content":"−2\r\n-3\r\n-X.Y\r\n-X.Y−32\r\n\r\nLaunch the latest Python 2.X version\r\nLaunch the latest Python 3.X version\r\nLaunch the specified Python version (X is 2 or 3)\r\nLaunch the specified 32-bit Python version\r\n\r\nAnd the launcher’s command lines take the following general form:\r\npy [py.exe arg] [python.exe args] script.py [script.py args]\r\n\r\nAnything following the launcher’s own argument (if present) is treated as though it\r\nwere passed to the python.exe program—typically, this includes any arguments for\r\nPython itself, followed by the script filename, followed by any arguments meant for the\r\nscript.\r\nThe usual -m mod, -c cmd, and - program specification forms work in a py command\r\nline too, as do all the other Python command-line arguments covered in Appendix A.\r\nAs mentioned earlier, arguments to python.exe can also appear at the end of the #!\r\ndirective line in a file, if used, though arguments in py command lines override them.\r\nTo see how this works, let’s write a new script that extends the prior to display command-line arguments; sys.argv is the script’s own arguments, and I’m using the Python\r\n(python.exe) -i switch, which directs it to the interactive prompt (>>>) after a script\r\nruns:\r\n# args.py, show my arguments too\r\nimport sys\r\nprint(sys.version.split()[0])\r\nprint(sys.argv)\r\nC:\\code> py −3 -i args.py -a 1 -b -c\r\n3.3.0\r\n['args.py', '-a', '1', '-b', '-c']\r\n>>> ^Z\r\n\r\n# −3: py, -i: python, rest: script\r\n\r\nC:\\code> py -i args.py -a 1 -b -c\r\n2.7.3\r\n['args.py', '-a', '1', '-b', '-c']\r\n>>> ^Z\r\n\r\n# Args to python, script\r\n\r\nC:\\code> py −3 -c print(99)\r\n99\r\n\r\n# −3 to py, rest to python: \"-c cmd\"\r\n\r\nC:\\code> py −2 -c \"print 99\"\r\n99\r\n\r\nNotice how the first two launches run the default Python unless a version is given in\r\nthe command line, because no #! line appears in the script itself. Somewhat coincidentally, that leads us to the last topic of this tutorial.\r\n\r\nStep 3: Using and Changing Defaults\r\nAs also mentioned, the launcher defaults to 2.X for a generic python in a #! directive\r\nwith no specific version number. This is true whether this generic form appears in a\r\nA Windows Launcher Tutorial | 1445"}},{"_index":"docs","_type":"page","_id":"a5596049972f8cd4381a110425c56f9e","_score":3.324298,"_source":{"id":"a5596049972f8cd4381a110425c56f9e","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1461","title":"Learning Python.txt","headers":"","content":"#!/bin/python\r\n...\r\nC:\\code> what.py\r\nUnable to create process using '/bin/python \"C:\\code\\what.py\" '\r\nC:\\code> py what.py\r\nUnable to create process using '/bin/python what.py'\r\nC:\\code> py −3 what.py\r\n3.3.0\r\n\r\nTechnically, the launcher recognizes Unix-style #! lines at the top of script files that\r\nfollow one of the following four patterns:\r\n#!/usr/bin/env python*\r\n#!/usr/bin/python*\r\n#!/usr/local/bin/python*\r\n#!python*\r\n\r\nAny #! line that does not take one of these recognized and parseable forms is assumed\r\nto be a fully specified command line to start a process to run the file, which is passed\r\nto Windows as is, and generates the error message we saw previously if it is not a valid\r\nWindows command. (The launcher also supports “customized” command expansions\r\nvia its configuration files, which are attempted before passing unrecognized commands\r\non to Windows, but we’ll gloss over these here.)\r\nIn recognizable #! lines, directory paths are coded per Unix convention, for portability\r\nto that platform. The * part at the end of the four preceding recognized patterns denotes\r\nan optional Python version number, in one of three forms:\r\nPartial (e.g., python3)\r\nTo run the version installed with the highest minor release number among those\r\nwith the major release number given\r\nFull (e.g., python3.1)\r\nTo run that specific version only, optionally suffixed by −32 to prefer a 32-bit version (e.g., python3.1-32)\r\nOmitted (e.g., python)\r\nTo run the launcher’s default version, which is 2 unless changed (e.g., by setting\r\nthe PY_PYTHON environment variable to 3), another pitfall described ahead\r\nFiles with no #! line at all behave the same as those that name just a generic python—\r\nthe aforementioned omitted case—and are influenced by PY_PYTHON default settings.\r\nThe first case, partials, may also be affected by version-specific environment settings\r\n(e.g., set PY_PYTHON3 to 3.1 to select 3.1 for python3, and set PY_PYTHON2 to 2.6 to pick\r\n2.6 for python2). We'll revisit defaults later in this tutorial.\r\nFirst, though, note that anything after the * part in a #! line’s format is assumed to be\r\ncommand-line arguments to Python itself (i.e., program python.exe), unless you also\r\n\r\nA Windows Launcher Tutorial | 1443"}},{"_index":"docs","_type":"page","_id":"e08318611fbfce760669697147fe6204","_score":3.2365344,"_source":{"id":"e08318611fbfce760669697147fe6204","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1459","title":"Learning Python.txt","headers":"","content":"Especially in the current dual 2.X/3.X Python world, explicit version selection seems a\r\nuseful addition for Windows, where many (and probably most) newcomers get their\r\nfirst exposure to the language. Although it is not without potential pitfalls—including\r\nfailures on unrecognized Unix #! lines and a puzzling 2.X default—it does allow for a\r\nmore graceful coexistence of 2.X and 3.X files on the same machine, and provides a\r\nrational approach to version control in command lines.\r\nFor the complete story on the Windows launcher, including more advanced features\r\nand use cases I’ll either condense or largely omit here, see Python’s release notes and\r\ntry a web search to find the PEP (the proposal document). Among other things, the\r\nlauncher also allows selecting between 32- and 64-bit installs, specifying defaults in\r\nconfiguration files, and defining custom #! command string expansion.\r\n\r\nA Windows Launcher Tutorial\r\nSome readers familiar with Unix scripting may find the prior section enough to get\r\nstarted. For others, this section provides additional context in the form of a tutorial,\r\nwhich gives concrete examples of the launcher in action for you to trace through. This\r\nsection also discloses additional launcher details along the way, though, so even wellseasoned Unix veterans may benefit from a quick scan here before FTPing all their\r\nPython scripts to the local Windows box.\r\nTo get started, we’ll be using the following simple script, what.py, which can be run\r\nunder both 2.X and 3.X to echo the version number of the Python that runs its code.\r\nIt uses sys.version—a string whose first component after splitting on whitespace is\r\nPython’s version number:\r\n#!python3\r\nimport sys\r\nprint(sys.version.split()[0])\r\n\r\n# First part of string\r\n\r\nIf you want to work along, type this script’s code in your favorite text file editor, open\r\na Command Prompt window for typing the command lines we’ll be running, and cd to\r\nthe directory where you’ve save the script (C:\\code is where I’m working, but feel free\r\nto save this wherever you wish, and see Chapter 3 for more Windows usage pointers).\r\nThis script’s first-line comment serves to designate the required Python version; it must\r\nbegin with #! per Unix convention, and allows for a space before the python3 or not.\r\nOn my machine I currently have Pythons 2.7, 3,1, 3.2, and 3.3 all installed; let’s watch\r\nwhich version is invoked as the script’s first line is modified in the following sections,\r\nexploring file directives, command lines, and defaults along the way.\r\n\r\nStep 1: Using Version Directives in Files\r\nAs this script is coded, when run by icon click or command line, the first line directs\r\nthe registered py.exe launcher to run using the latest 3.X installed:\r\n\r\nA Windows Launcher Tutorial | 1441"}},{"_index":"docs","_type":"page","_id":"c083a626b9fb62b90b150970d52b2c69","_score":3.220156,"_source":{"id":"c083a626b9fb62b90b150970d52b2c69","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:709","title":"Learning Python.txt","headers":"","content":"files still get the .pyc extension as before, they are given more descriptive names\r\nthat include text identifying the version of Python that created them (e.g., module.cpython-32.pyc). This avoids contention and recompiles: because each version\r\nof Python installed can have its own uniquely named version of byte code files in\r\nthe __pycache__ subdirectory, running under a given version doesn’t overwrite the\r\nbyte code of another, and doesn’t require recompiles. Technically, byte code filenames also include the name of the Python that created them, so CPython, Jython,\r\nand other implementations mentioned in the preface and Chapter 2 can coexist on\r\nthe same machine without stepping on each other’s work (once they support this\r\nmodel).\r\nIn both models, Python always recreates the byte code file if you’ve changed the source\r\ncode file since the last compile, but version differences are handled differently—by\r\nmagic numbers and replacement prior to 3.2, and by filenames that allow for multiple\r\ncopies in 3.2 and later.\r\n\r\nByte Code File Models in Action\r\nThe following is a quick example of these two models in action under 2.X and 3.3. I’ve\r\nomitted much of the text displayed by the dir directory listing on Windows here to\r\nsave space, and the script used here isn’t listed because it is not relevant to this discussion (it’s from Chapter 2, and simply prints two values). Prior to 3.2, byte code files\r\nshow up alongside their source files after being created by import operations:\r\nc:\\code\\py2x> dir\r\n10/31/2012 10:58 AM\r\n\r\n39 script0.py\r\n\r\nc:\\code\\py2x> C:\\python27\\python\r\n>>> import script0\r\nhello world\r\n1267650600228229401496703205376\r\n>>> ^Z\r\nc:\\code\\py2x> dir\r\n10/31/2012 10:58 AM\r\n10/31/2012 11:00 AM\r\n\r\n39 script0.py\r\n154 script0.pyc\r\n\r\nHowever, in 3.2 and later byte code files are saved in the __pycache__ subdirectory and\r\ninclude versions and Python implementation details in their names to avoid clutter and\r\ncontention among the Pythons on your computer:\r\nc:\\code\\py2x> cd ..\\py3x\r\nc:\\code\\py3x> dir\r\n10/31/2012 10:58 AM\r\n\r\n39 script0.py\r\n\r\nc:\\code\\py3x> C:\\python33\\python\r\n>>> import script0\r\nhello world\r\n1267650600228229401496703205376\r\n>>> ^Z\r\n\r\nByte Code Files: __pycache__ in Python 3.2+ | 677"}},{"_index":"docs","_type":"page","_id":"5444ab853cd8dc9fdbfb963967af8ba1","_score":3.194374,"_source":{"id":"5444ab853cd8dc9fdbfb963967af8ba1","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:457","title":"Learning Python.txt","headers":"","content":"The net effect of this magic is that, as mentioned in Chapter 9 and Chapter 13, the best\r\nway to read a text file line by line today is to not read it at all—instead, allow the for\r\nloop to automatically call __next__ to advance to the next line on each iteration. The\r\nfile object’s iterator will do the work of automatically loading lines as you go. The\r\nfollowing, for example, reads a file line by line, printing the uppercase version of each\r\nline along the way, without ever explicitly reading from the file at all:\r\n>>> for line in open('script2.py'):\r\n...\r\nprint(line.upper(), end='')\r\n...\r\nIMPORT SYS\r\nPRINT(SYS.PATH)\r\nX = 2\r\nPRINT(X ** 32)\r\n\r\n# Use file iterators to read by lines\r\n# Calls __next__, catches StopIteration\r\n\r\nNotice that the print uses end='' here to suppress adding a \\n, because line strings\r\nalready have one (without this, our output would be double-spaced; in 2.X, a trailing\r\ncomma works the same as the end). This is considered the best way to read text files\r\nline by line today, for three reasons: it’s the simplest to code, might be the quickest to\r\nrun, and is the best in terms of memory usage. The older, original way to achieve the\r\nsame effect with a for loop is to call the file readlines method to load the file’s content\r\ninto memory as a list of line strings:\r\n>>> for line in open('script2.py').readlines():\r\n...\r\nprint(line.upper(), end='')\r\n...\r\nIMPORT SYS\r\nPRINT(SYS.PATH)\r\nX = 2\r\nPRINT(X ** 32)\r\n\r\nThis readlines technique still works but is not considered the best practice today and\r\nperforms poorly in terms of memory usage. In fact, because this version really does load\r\nthe entire file into memory all at once, it will not even work for files too big to fit into\r\nthe memory space available on your computer. By contrast, because it reads one line\r\nat a time, the iterator-based version is immune to such memory-explosion issues. The\r\niterator version might run quicker too, though this can vary per release\r\nAs mentioned in the prior chapter’s sidebar, “Why You Will Care: File Scanners” on page 400, it’s also possible to read a file line by line with a while loop:\r\n>>> f = open('script2.py')\r\n>>> while True:\r\n...\r\nline = f.readline()\r\n...\r\nif not line: break\r\n...\r\nprint(line.upper(), end='')\r\n...\r\n...same output...\r\n\r\nHowever, this may run slower than the iterator-based for loop version, because iterators run at C language speed inside Python, whereas the while loop version runs Python\r\nbyte code through the Python virtual machine. Anytime we trade Python code for C\r\n418 | Chapter 14: Iterations and Comprehensions"}},{"_index":"docs","_type":"page","_id":"6f9428a3239dd587ad30fede7d70f557","_score":3.1642752,"_source":{"id":"6f9428a3239dd587ad30fede7d70f557","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1453","title":"Learning Python.txt","headers":"","content":"print(1 / X)\r\nC:\\code> python divbad.py\r\n...error text omitted\r\nZeroDivisionError: division by zero\r\n\r\n# Run the buggy script\r\n\r\nC:\\code> python -i divbad.py\r\n...error text omitted\r\nZeroDivisionError: division by zero\r\n>>> X\r\n0\r\n>>> import pdb\r\n>>> pdb.pm()\r\n> C:\\code\\divbad.py(2)<module>()\r\n-> print(1 / X)\r\n(Pdb) quit\r\n\r\n# Print variable values at error\r\n\r\n# Start full debugger session now\r\n\r\nPython 2.X command-line arguments\r\nBesides those just mentioned, Python 2.7 supports additional options that promote 3.X\r\ncompatibility (−3 to warn about incompatibilities, and –Q to control division operator\r\nmodels) and detecting inconsistent tab indentation usage, which is always detected and\r\nreported in 3.X (-t; see Chapter 12). Again, you can always ask Python 2.X itself for\r\nmore on the subject as needed:\r\nC:\\code> c:\\python27\\python -h\r\n\r\nPython 3.3 Windows Launcher Command Lines\r\nTechnically, the preceding section described the arguments you can pass to the Python\r\ninterpreter itself—the program usually named python.exe on Windows, and python on\r\nLinux (the .exe is normally omitted on Windows). As we’ll see in the next appendix,\r\nthe Windows launcher shipped with Python 3.3 augments this story for users of 3.3\r\nand later or the standalone launcher package. It adds new executables that accept\r\nPython version numbers as arguments in command lines used to start Python and your\r\nscripts (file what.py is listed and described in the next appendix, and simply prints the\r\nPython version number):\r\nC:\\code> py what.py\r\n3.3.0\r\n\r\n# Windows launcher command lines\r\n\r\nC:\\code> py −2 what.py\r\n2.7.3\r\n\r\n# Version number switch\r\n\r\nC:\\code> py −3.3 -i what.py -a -b -c\r\n3.3.0\r\n>>> ^Z\r\n\r\n# Arguments for all 3: py, python, script\r\n\r\nIn fact, as the last run of the preceding example shows, command lines using the\r\nlauncher can give arguments for the launcher itself (−3.3), Python itself (-i), and your\r\nscript (-a, -b, and -c). The launcher can also parse version numbers out of #! Unix lines\r\n\r\nConfiguring Python | 1435"}},{"_index":"docs","_type":"page","_id":"e75bb1ab888f6de8de18f83494965ab1","_score":3.1502452,"_source":{"id":"e75bb1ab888f6de8de18f83494965ab1","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1462","title":"Learning Python.txt","headers":"","content":"give arguments in a py command line that are deemed to supersede #! line arguments\r\nby the launcher:\r\n#!python3 [any python.exe arguments go here]\r\n...\r\n\r\nThese include all the Python command-line arguments we met in Appendix A. But this\r\nleads us to launcher command lines in general, and will suffice as a natural segue to\r\nthe next section.\r\n\r\nStep 2: Using Command-Line Version Switches\r\nAs mentioned, version switches on command lines can be used to select a Python version if one isn’t present in the file. You run a py or pyw command line to pass them a\r\nswitch this way, instead of relying on filename associations in the registry, and instead\r\nof (or in addition to) giving versions in #! lines in files. In the following, we modify our\r\nscript so that it has no #! directive:\r\n# not a launcher directive\r\n...\r\nC:\\code> py −3 what.py\r\n3.3.0\r\n\r\n# Run per command-line switch\r\n\r\nC:\\code> py −2 what.py\r\n2.7.3\r\n\r\n# Ditto: latest 2.X installed\r\n\r\nC:\\code> py −3.2 what.py\r\n3.2.3\r\n\r\n# Ditto: 3.2 specifically (and only)\r\n\r\nC:\\code> py what.py\r\n2.7.3\r\n\r\n# Run per launcher's default (ahead)\r\n\r\nBut command-line switches also take precedence over a version designation in a file’s\r\ndirective:\r\n#! python3.1\r\n...\r\nC:\\code> what.py\r\n3.1.4\r\n\r\n# Run per file directive\r\n\r\nC:\\code> py what.py\r\n3.1.4\r\n\r\n# Ditto\r\n\r\nC:\\code> py −3.2 what.py\r\n3.2.3\r\n\r\n# Switches override directives\r\n\r\nC:\\code> py −2 what.py\r\n2.7.3\r\n\r\n# Ditto\r\n\r\nFormally, the launcher accepts the following command-line argument types (which\r\nexactly mirror the * part at the end of a file’s #! line described in the prior section):\r\n\r\n1444 | Appendix B: The Python 3.3 Windows Launcher"}},{"_index":"docs","_type":"page","_id":"82e656b4c979a29332f47c814696d357","_score":3.133455,"_source":{"id":"82e656b4c979a29332f47c814696d357","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:37","title":"Learning Python.txt","headers":"","content":"For instance, I’ll use 3.X print calls in most examples, but will also describe the 2.X\r\nprint statement so you can make sense of earlier code, and will often use portable\r\nprinting techniques that run on both lines. I’ll also freely introduce new features, such\r\nas the nonlocal statement in 3.X and the string format method available as of 2.6 and\r\n3.0, and will point out when such extensions are not present in older Pythons.\r\nBy proxy, this edition addresses other Python version 2.X and 3.X releases as well,\r\nthough some older version 2.X code may not be able to run all the examples here.\r\nAlthough class decorators are available as of both Python 2.6 and 3.0, for example, you\r\ncannot use them in an older Python 2.X that did not yet have this feature. Again, see\r\nthe change tables in Appendix C for summaries of recent 2.X and 3.X changes.\r\n\r\nWhich Python Should I Use?\r\nVersion choice may be mandated by your organization, but if you’re new to Python\r\nand learning on your own, you may be wondering which version to install. The answer\r\nhere depends on your goals. Here are a few suggestions on the choice.\r\nWhen to choose 3.X: new features, evolution\r\nIf you are learning Python for the first time and don’t need to use any existing 2.X\r\ncode, I encourage you to begin with Python 3.X. It cleans up some longstanding\r\nwarts in the language and trims some dated cruft, while retaining all the original\r\ncore ideas and adding some nice new tools. For example, 3.X’s seamless Unicode\r\nmodel and broader use of generators and functional techniques are seen by many\r\nusers as assets. Many popular Python libraries and tools are already available for\r\nPython 3.X, or will be by the time you read these words, especially given the continual improvements in the 3.X line. All new language evolution occurs in 3.X only,\r\nwhich adds features and keeps Python relevant, but also makes language definition\r\na constantly moving target—a tradeoff inherent on the leading edge.\r\nWhen to choose 2.X: existing code, stability\r\nIf you’ll be using a system based on Python 2.X, the 3.X line may not be an option\r\nfor you today. However, you’ll find that this book addresses your concerns, too,\r\nand will help if you migrate to 3.X in the future. You’ll also find that you’re in large\r\ncompany. Every group I taught in 2012 was using 2.X only, and I still regularly see\r\nuseful Python software in 2.X-only form. Moreover, unlike 3.X, 2.X is no longer\r\nbeing changed—which is either an asset or liability, depending on whom you ask.\r\nThere’s nothing wrong with using and writing 2.X code, but you may wish to keep\r\ntabs on 3.X and its ongoing evolution as you do. Python’s future remains to be\r\nwritten, and is largely up to its users, including you.\r\nWhen to choose both: version-neutral code\r\nProbably the best news here is that Python’s fundamentals are the same in both its\r\nlines—2.X and 3.X differ in ways that many users will find minor, and this book\r\nis designed to help you learn both. In fact, as long as you understand their differences, it’s often straightforward to write version-neutral code that runs on both\r\nxxxviii | Preface"}},{"_index":"docs","_type":"page","_id":"2ff7fc005550cea4289484b8edb778dc","_score":3.1249218,"_source":{"id":"2ff7fc005550cea4289484b8edb778dc","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:734","title":"Learning Python.txt","headers":"","content":"• Reloads impact all clients that use import to fetch modules. Because clients\r\nthat use import qualify to fetch attributes, they’ll find new values in the module\r\nobject after a reload.\r\n• Reloads impact future from clients only. Clients that used from to fetch attributes\r\nin the past won’t be affected by a reload; they’ll still have references to the old\r\nobjects fetched before the reload.\r\n• Reloads apply to a single module only. You must run them on each module you\r\nwish to update, unless you use code or tools that apply reloads transitively.\r\n\r\nreload Example\r\nTo demonstrate, here’s a more concrete example of reload in action. In the following,\r\nwe’ll change and reload a module file without stopping the interactive Python session.\r\nReloads are used in many other scenarios, too (see the sidebar “Why You Will Care:\r\nModule Reloads” on page 703), but we’ll keep things simple for illustration here.\r\nFirst, in the text editor of your choice, write a module file named changer.py with the\r\nfollowing contents:\r\nmessage = \"First version\"\r\ndef printer():\r\nprint(message)\r\n\r\nThis module creates and exports two names—one bound to a string, and another to a\r\nfunction. Now, start the Python interpreter, import the module, and call the function\r\nit exports. The function will print the value of the global message variable:\r\n% python\r\n>>> import changer\r\n>>> changer.printer()\r\nFirst version\r\n\r\nKeeping the interpreter active, now edit the module file in another window:\r\n...modify changer.py without stopping Python...\r\n% notepad changer.py\r\n\r\nChange the global message variable, as well as the printer function body:\r\nmessage = \"After editing\"\r\ndef printer():\r\nprint('reloaded:', message)\r\n\r\nThen, return to the Python window and reload the module to fetch the new code. Notice\r\nin the following interaction that importing the module again has no effect; we get the\r\noriginal message, even though the file’s been changed. We have to call reload in order\r\nto get the new version:\r\n...back to the Python interpreter...\r\n>>> import changer\r\n>>> changer.printer()\r\nFirst version\r\n>>> from imp import reload\r\n\r\n702 | Chapter 23: Module Coding Basics\r\n\r\n# No effect: uses loaded module"}},{"_index":"docs","_type":"page","_id":"4c2514763f16dd02cf9511fc2a0fbc48","_score":3.101575,"_source":{"id":"4c2514763f16dd02cf9511fc2a0fbc48","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1456","title":"Learning Python.txt","headers":"","content":"By making such a script executable (e.g., via chmod +x script.py), you can run it by\r\ngiving just its filename in a command line; the #! line at the top then directs the Unix\r\nshell to a program that will run the rest of the file’s code. Depending on the platform’s\r\ninstall structure, the python that these #! lines name might be a real executable, or a\r\nsymbolic link to a version-specific executable located elsewhere. These lines might also\r\nname a more specific executable explicitly, such as python3. Either way, by changing\r\n#! lines, symbolic links, or PATH settings, Unix developers can route a script to the\r\nappropriate installed Python.\r\nNone of this applies to Windows itself, of course, where #! lines have no inherent\r\nmeaning. Python itself has historically ignored such lines as comments if present on\r\nWindows (“#” starts a comment in the language). Still, the idea of selecting Python\r\nexecutables on a per-file basis is a compelling feature in a world where Python 2.X and\r\n3.X often coexist on the same machine. Given that many programmers coded #! lines\r\nfor portability to Unix anyhow, the idea seemed ripe for emulating.\r\n\r\nThe Windows Legacy\r\nThe install model has been very different on the other side of the fence. In the past (well,\r\nin every Python until 3.3), the Windows installer updated the global Windows registry\r\nsuch that the latest Python version installed on your computer was the version that\r\nopened Python files when they were clicked or run by direct filename in command lines.\r\nSome Windows users may know this registry as filename associations, configurable in\r\nControl Panel’s Default Programs dialog. You do not need to give files executable privileges for this to work, as you do for Unix scripts. In fact, there’s no such concept on\r\nWindows—filename associations and commands suffice to launch files as programs.\r\nUnder this install model, if you wished to open a file with a different version than the\r\nlatest install, you had to run a command line giving the full path to the Python you\r\nwanted, or update your filename associations manually to use the desired version. You\r\ncould also point generic python command lines to a specific Python by setting or changing your PATH setting, but Python didn’t set this for you, and this wouldn’t apply to\r\nscripts launched by icon clicks and other contexts.\r\nThis reflects the natural order on Windows (when you click on a .doc file, Windows\r\nusually opens it in the latest Word installed), and has been the state of things ever since\r\nthere was a Python on Windows. It’s less ideal if you have Python scripts that require\r\ndifferent versions on the same machine, though—a situation that has become increasingly common, and perhaps even normal in the dual Python 2.X/3.X era. Running\r\nmultiple Pythons on Windows prior to 3.3 can be tedious for developers, and discouraging for newcomers.\r\n\r\n1438 | Appendix B: The Python 3.3 Windows Launcher"}},{"_index":"docs","_type":"page","_id":"795df1febc984329fa14ec3ab8c1c4b0","_score":3.0866518,"_source":{"id":"795df1febc984329fa14ec3ab8c1c4b0","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:707","title":"Learning Python.txt","headers":"","content":"2. Compile It (Maybe)\r\nAfter finding a source code file that matches an import statement by traversing the\r\nmodule search path, Python next compiles it to byte code, if necessary. We discussed\r\nbyte code briefly in Chapter 2, but it’s a bit richer than explained there. During an\r\nimport operation Python checks both file modification times and the byte code’s Python\r\nversion number to decide how to proceed. The former uses file “timestamps,” and the\r\nlatter uses either a “magic” number embedded in the byte code or a filename, depending\r\non the Python release being used. This step chooses an action as follows:\r\nCompile\r\nIf the byte code file is older than the source file (i.e., if you’ve changed the source)\r\nor was created by a different Python version, Python automatically regenerates the\r\nbyte code when the program is run.\r\nAs discussed ahead, this model is modified somewhat in Python 3.2 and later—\r\nbyte code files are segregated in a __pycache__ subdirectory and named with their\r\nPython version to avoid contention and recompiles when multiple Pythons are\r\ninstalled. This obviates the need to check version numbers in the byte code, but\r\nthe timestamp check is still used to detect changes in the source.\r\nDon’t compile\r\nIf, on the other hand, Python finds a .pyc byte code file that is not older than the\r\ncorresponding .py source file and was created by the same Python version, it skips\r\nthe source-to-byte-code compile step.\r\nIn addition, if Python finds only a byte code file on the search path and no source,\r\nit simply loads the byte code directly; this means you can ship a program as just\r\nbyte code files and avoid sending source. In other words, the compile step is bypassed if possible to speed program startup.\r\nNotice that compilation happens when a file is being imported. Because of this, you\r\nwill not usually see a .pyc byte code file for the top-level file of your program, unless it\r\nis also imported elsewhere—only imported files leave behind .pyc files on your machine. The byte code of top-level files is used internally and discarded; byte code of\r\nimported files is saved in files to speed future imports.\r\nTop-level files are often designed to be executed directly and not imported at all. Later,\r\nwe’ll see that it is possible to design a file that serves both as the top-level code of a\r\nprogram and as a module of tools to be imported. Such a file may be both executed\r\nand imported, and thus does generate a .pyc. To learn how this works, watch for the\r\ndiscussion of the special __name__ attribute and __main__ in Chapter 25.\r\n\r\n3. Run It\r\nThe final step of an import operation executes the byte code of the module. All statements in the file are run in turn, from top to bottom, and any assignments made to\r\nnames during this step generate attributes of the resulting module object. This is how\r\nHow Imports Work | 675"}},{"_index":"docs","_type":"page","_id":"797719923b055b042c394c51d6409f19","_score":3.0753343,"_source":{"id":"797719923b055b042c394c51d6409f19","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1458","title":"Learning Python.txt","headers":"","content":"#!python3\r\n...\r\n...a 3.X script\r\n...\r\n#!python2\r\n...\r\n...a 2.X script\r\n...\r\n#!python2.6\r\n...\r\n...a 2.6 script\r\n...\r\n\r\n# Runs under latest 3.X installed\r\n\r\n# Runs under latest 2.X installed\r\n\r\n# Runs under 2.6 (only)\r\n\r\nOn Windows, command lines are typed in a Command Prompt window, designated\r\nby its C:\\code> prompt in this appendix. The first of the following is the same as both\r\nthe second and an icon click, because of filename associations:\r\nC:\\code> script.py\r\nC:\\code> py script.py\r\n\r\n# Run per file's #! line if present, else per default\r\n# Ditto, but py.exe is run explicitly\r\n\r\nAlternatively, the second technique just listed can select versions with argument\r\nswitches in command lines instead:\r\nC:\\code> py −3 script.py\r\nC:\\code> py −2 script.py\r\nC:\\code> py −2.6 script.py\r\n\r\n# Runs under latest 3.X\r\n# Runs under latest 2.X\r\n# Runs under 2.6 (only)\r\n\r\nThis works both when launching scripts and starting the interactive interpreter (when\r\nno script is named):\r\nC:\\code>\r\nC:\\code>\r\nC:\\code>\r\nC:\\code>\r\n\r\npy −3\r\npy −2\r\npy −3.1\r\npy\r\n\r\n# Starts latest 3.X, interactive\r\n# Starts latest 2.X, interactive\r\n# Starts 3.1 (only), interactive\r\n# Starts default Python (initially 2.X: see ahead)\r\n\r\nIf there are both #! lines in the file and a version number switch in the command line\r\nused to start it, the command line’s version overrides that in the file’s directive:\r\n#! python3.2\r\n...\r\n...a 3.X script\r\n...\r\nC\\code> py script.py\r\nC\\code> py −3.1 script.py\r\n\r\n# Runs under 3.2, per file directive\r\n# Runs under 3.1, even if 3.2 present\r\n\r\nThe launcher also applies heuristics to select a specific Python version when it is missing\r\nor only partly described. For instance, the latest 2.X is run when only a 2 is specified,\r\nand a 2.X is preferred for files that do not name a version in a #! line when launched\r\nby icon click or generic command lines (e.g., py m.py, m.py), unless you configure the\r\ndefault to use 3.X instead by setting PY_PYTHON or a configuration file entry (more on\r\nthis ahead).\r\n\r\n1440 | Appendix B: The Python 3.3 Windows Launcher"}},{"_index":"docs","_type":"page","_id":"5f0a582e5f7ef57c176923d3970b6cef","_score":3.0674012,"_source":{"id":"5f0a582e5f7ef57c176923d3970b6cef","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1457","title":"Learning Python.txt","headers":"","content":"Introducing the New Windows Launcher\r\nThe new Windows launcher, shipped and installed automatically with Python 3.3 (and\r\npresumably later), and available as a standalone package for use with other versions,\r\naddresses these deficits in the former install model by providing two new executables:\r\n• py.exe for console programs\r\n• pyw.exe for nonconsole (typically GUI) programs\r\nThese two programs are registered to open .py and .pyw files, respectively, via Windows\r\nfilename associations. Like Python’s original python.exe main program (which they do\r\nnot deprecate but can largely subsume), these new executables are also registered to\r\nopen byte code files launched directly. Amongst their weapons, these two new executables:\r\n• Automatically open Python source and byte-code files launched by icon clicks or\r\nfilename commands, via Windows associations\r\n• Are normally installed on your system search path and do not require a directory\r\npath or PATH settings when used as command lines\r\n• Allow Python version numbers to be passed in easily as command-line arguments,\r\nwhen starting both scripts and interactive sessions\r\n• Attempt to parse Unix-style #! comment lines at the top of scripts to determine\r\nwhich Python version should be used to run a file’s code\r\nThe net effect is that under the new launcher, when multiple Pythons are installed on\r\nWindows, you are no longer limited to either the latest version installed or explicit/full\r\ncommand lines. Instead, you can now select versions explicitly on both a per-file and\r\nper-command basis, and specify versions in either partial or full form in both contexts.\r\nHere’s how this works:\r\n1. To select versions per file, use Unix-style top-of-script comments like these:\r\n#!python2\r\n#!/usr/bin/python2.7\r\n#!/usr/bin/env python3\r\n\r\n2. To select versions per command, use command lines of the following forms:\r\npy −2 m.py\r\npy −2.7 m.py\r\npy −3 m.py\r\n\r\nFor example, the first of these techniques can serve as a sort of directive to declare which\r\nPython version the script depends upon, and will be applied by the launcher whenever\r\nthe script is run by command line or icon click (these are variants of a file named\r\nscript.py):\r\n\r\nIntroducing the New Windows Launcher | 1439"}},{"_index":"docs","_type":"page","_id":"960a25007c1324967ebf50d99e37f788","_score":3.0314615,"_source":{"id":"960a25007c1324967ebf50d99e37f788","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:857","title":"Learning Python.txt","headers":"","content":"For the sake of argument, let’s assume that when a Manager gets a raise, it receives the\r\npassed-in percentage as usual, but also gets an extra bonus that defaults to 10%. For\r\ninstance, if a Manager’s raise is specified as 10%, it will really get 20%. (Any relation to\r\nPersons living or dead is, of course, strictly coincidental.) Our new method begins as\r\nfollows; because this redefinition of giveRaise will be closer in the class tree to Man\r\nager instances than the original version in Person, it effectively replaces, and thereby\r\ncustomizes, the operation. Recall that according to the inheritance search rules, the\r\nlowest version of the name wins:1\r\n# Inherit Person attrs\r\n# Redefine to customize\r\n\r\nclass Manager(Person):\r\ndef giveRaise(self, percent, bonus=.10):\r\n\r\nAugmenting Methods: The Bad Way\r\nNow, there are two ways we might code this Manager customization: a good way and a\r\nbad way. Let’s start with the bad way, since it might be a bit easier to understand. The\r\nbad way is to cut and paste the code of giveRaise in Person and modify it for Manager,\r\nlike this:\r\nclass Manager(Person):\r\ndef giveRaise(self, percent, bonus=.10):\r\nself.pay = int(self.pay * (1 + percent + bonus))\r\n\r\n# Bad: cut and paste\r\n\r\nThis works as advertised—when we later call the giveRaise method of a Manager instance, it will run this custom version, which tacks on the extra bonus. So what’s wrong\r\nwith something that runs correctly?\r\nThe problem here is a very general one: anytime you copy code with cut and paste, you\r\nessentially double your maintenance effort in the future. Think about it: because we\r\ncopied the original version, if we ever have to change the way raises are given (and we\r\nprobably will), we’ll have to change the code in two places, not one. Although this is a\r\nsmall and artificial example, it’s also representative of a universal issue—anytime you’re\r\ntempted to program by copying code this way, you probably want to look for a better\r\napproach.\r\n\r\nAugmenting Methods: The Good Way\r\nWhat we really want to do here is somehow augment the original giveRaise, instead of\r\nreplacing it altogether. The good way to do that in Python is by calling to the original\r\nversion directly, with augmented arguments, like this:\r\nclass Manager(Person):\r\ndef giveRaise(self, percent, bonus=.10):\r\nPerson.giveRaise(self, percent + bonus)\r\n\r\n# Good: augment original\r\n\r\n1. And no offense to any managers in the audience, of course. I once taught a Python class in New Jersey,\r\nand nobody laughed at this joke, among others. The organizers later told me it was a group of managers\r\nevaluating Python.\r\n\r\nStep 4: Customizing Behavior by Subclassing | 829"}},{"_index":"docs","_type":"page","_id":"12be7635e960f37487326dbfb1bb4757","_score":3.0273523,"_source":{"id":"12be7635e960f37487326dbfb1bb4757","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:759","title":"Learning Python.txt","headers":"","content":"from . import string\r\nprint(string)\r\n\r\n# <== Relative in both 2.X and 3.X\r\n\r\n# code\\pkg\\string.py\r\nprint('Ni' * 8)\r\n\r\nWhen we import the string module with relative import syntax like this, we get the\r\nversion in the package in both 2.X and 3.X, as desired:\r\nC:\\code> c:\\Python33\\python\r\n# Same result in 2.X\r\n>>> import pkg.spam\r\nNiNiNiNiNiNiNiNi\r\n<module 'pkg.string' from '.\\\\pkg\\\\string.py'>\r\n\r\nWhen absolute syntax is used, though, the module we get varies per version again. 2.X\r\ninterprets this as relative to the package first, but 3.X makes it “absolute,” which in this\r\ncase really just means it skips the package and loads the version relative to the CWD\r\n—not the version in the standard library:\r\n# code\\string.py\r\nprint('string' * 8)\r\n# code\\pkg\\spam.py\r\nimport string\r\nprint(string)\r\n\r\n# <== Relative in 2.X, \"absolute\" in 3.X: CWD!\r\n\r\n# code\\pkg\\string.py\r\nprint('Ni' * 8)\r\nC:\\code> c:\\Python33\\python\r\n>>> import pkg.spam\r\nstringstringstringstringstringstringstringstring\r\n<module 'string' from '.\\\\string.py'>\r\nC:\\code> c:\\Python27\\python\r\n>>> import pkg.spam\r\nNiNiNiNiNiNiNiNi\r\n<module 'pkg.string' from 'pkg\\string.pyc'>\r\n\r\nAs you can see, although packages can explicitly request modules within their own\r\ndirectories with dots, their “absolute” imports are otherwise still relative to the rest of\r\nthe normal module search path. In this case, a file in the program using the package\r\nhides the standard library module the package may want. The change in 3.X simply\r\nallows package code to select files either inside or outside the package (i.e., relatively\r\nor absolutely). Because import resolution can depend on an enclosing context that may\r\nnot be foreseen, though, absolute imports in 3.X are not a guarantee of finding a module\r\nin the standard library.\r\nExperiment with these examples on your own for more insight. In practice, this is not\r\nusually as ad hoc as it might seem: you can generally structure your imports, search\r\npaths, and module names to work the way you wish during development. You should\r\nkeep in mind, though, that imports in larger systems may depend upon context of use,\r\nand the module import protocol is part of a successful library’s design.\r\n728 | Chapter 24: Module Packages"}},{"_index":"docs","_type":"page","_id":"ea0fa63e273fb7f0e32d72cb1c928127","_score":3.025873,"_source":{"id":"ea0fa63e273fb7f0e32d72cb1c928127","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:1466","title":"Learning Python.txt","headers":"","content":"Unix-style #! lines probably aren’t present in Windows-only programs, but can be\r\ncommon in programs meant to be run on Unix too. Treating unrecognized Unix directives as errors on Windows seems a bit extreme, especially given that this is new\r\nbehavior in 3.3, and will likely be unexpected. Why not just ignore unrecognized #!\r\nlines and run the file with the default Python—like every Windows Python to date has?\r\nIt’s possible that this might be improved in a future 3.X release (there may be some\r\npushback on this), but today you must change any files using a #!/bin/env or other\r\nunrecognized pattern, if you want them to run under the launcher installed with Python\r\n3.3 on Windows.\r\n\r\nBook examples impact and fix\r\nWith respect to the book examples I ported to 3.3, this broke roughly a dozen scripts\r\nthat started with #!/bin/env python. Regrettably, this includes some of the book’s userfriendly and top-level demo launcher scripts (PyGadgets and PyDemos). To fix, I\r\nchanged these to use the accepted #!/usr/bin/env python form instead. Altering your\r\nWindows file associations to omit the launcher altogether may be another option (e.g.,\r\nassociating .py files with python.exe instead of py.exe), but this negates the launcher’s\r\nbenefits, and seems a bit much to ask of users, especially newcomers.\r\nOne open issue here: strangely, passing any command-line switch to the launcher, even\r\na python.exe argument, seems to negate this effect and fall back on the default Python\r\n—m.py and py m.py both issue errors on unrecognized #! lines, but py -i m.py runs\r\nsuch a file with the default Python. This seems a possible launcher bug, but also relies\r\non the default, the subject of the next issue.\r\n\r\nPitfall 2: The Launcher Defaults to 2.X\r\nOddly, the Windows 3.3 launcher defaults to using an installed Python 2.X when running scripts that don’t select 3.X explicitly. That is, scripts that either have no #! directive or use one that names python generically will be run by a 2.X Python by default\r\nwhen launched by icon clicks, direct filename command lines (m.py), or launcher command lines that give no version switch (py m.py). This is true even if 3.3 is installed after\r\na 2.X on your machine, and has the potential to make many 3.X scripts fail initially.\r\nThe implications of this are potentially broad. As one example, clicking the icon of a\r\ndirective-less 3.X file just after installing 3.3 may now fail, because the associated\r\nlauncher assumes you mean to use 2.X by default. This probably won’t be a pleasant\r\nfirst encounter for some Python newcomers! This assumes the 3.X file has no #! directive that provides an explicit python3 version number, but most scripts meant to run\r\non Windows won’t have a #! line at all, and many files coded before the launcher came\r\nonline won’t accommodate its version number expectations. Most 3.X users will be\r\nbasically compelled to set PY_PYTHON after installing 3.3—hardly a usability win.\r\nProgram launches that don’t give an explicit version number might be arguably ambiguous on Unix too, and often rely on symbolic links from python to a specific version\r\n1448 | Appendix B: The Python 3.3 Windows Launcher"}},{"_index":"docs","_type":"page","_id":"e0cc7d98178e7072a932850fbcd17508","_score":2.988199,"_source":{"id":"e0cc7d98178e7072a932850fbcd17508","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:692","title":"Learning Python.txt","headers":"","content":">>> selector()\r\n99\r\n\r\nRemember, though, that this means the assignment also changes the global X, not a\r\nlocal X. Within a function, you can’t use both local and global versions of the same\r\nsimple name. If you really meant to print the global and then set a local of the same\r\nname, you’d need to import the enclosing module and use module attribute notation\r\nto get to the global version:\r\n>>> X = 99\r\n>>> def selector():\r\nimport __main__\r\nprint(__main__.X)\r\nX = 88\r\nprint(X)\r\n\r\n# Import enclosing module\r\n# Qualify to get to global version of name\r\n# Unqualified X classified as local\r\n# Prints local version of name\r\n\r\n>>> selector()\r\n99\r\n88\r\n\r\nQualification (the .X part) fetches a value from a namespace object. The interactive\r\nnamespace is a module called __main__, so __main__.X reaches the global version of X.\r\nIf that isn’t clear, check out Chapter 17.\r\nIn recent versions Python has improved on this story somewhat by issuing for this case\r\nthe more specific “unbound local” error message shown in the example listing (it used\r\nto simply raise a generic name error); this gotcha is still present in general, though.\r\n\r\nDefaults and Mutable Objects\r\nAs noted briefly in Chapter 17 and Chapter 18, mutable values for default arguments\r\ncan retain state between calls, though this is often unexpected. In general, default argument values are evaluated and saved once when a def statement is run, not each time\r\nthe resulting function is later called. Internally, Python saves one object per default\r\nargument attached to the function itself.\r\nThat’s usually what you want—because defaults are evaluated at def time, it lets you\r\nsave values from the enclosing scope, if needed (functions defined within loops by\r\nfactories may even depend on this behavior—see ahead). But because a default retains\r\nan object between calls, you have to be careful about changing mutable defaults. For\r\ninstance, the following function uses an empty list as a default value, and then changes\r\nit in place each time the function is called:\r\n>>> def saver(x=[]):\r\nx.append(1)\r\nprint(x)\r\n\r\n# Saves away a list object\r\n# Changes same object each time!\r\n\r\n>>> saver([2])\r\n[2, 1]\r\n>>> saver()\r\n[1]\r\n\r\n# Default not used\r\n\r\n658 | Chapter 21: The Benchmarking Interlude\r\n\r\n# Default used"}},{"_index":"docs","_type":"page","_id":"97ed774e68afb7768805364830c19ab7","_score":2.9668565,"_source":{"id":"97ed774e68afb7768805364830c19ab7","project":"Learning Python.txt","path":"C:\\Users\\pramod\\Desktop\\CodeWeek\\Learning Python.txt:107","title":"Learning Python.txt","headers":"","content":"will probably be simpler if you always use the basic command-line approach, not Unixstyle scripts, to launch programs.\r\nIf you’re using Python 3.3 or later, though, or have its Windows launcher installed\r\nseparately, it turns out that Unix-style #! lines do mean something on Windows too.\r\nBesides offering the py executable described earlier, the new Windows launcher mentioned earlier attempts to parse #! lines to determine which Python version to launch\r\nto run your script’s code. Moreover, it allows you to give the version number in full or\r\npartial forms, and recognizes most common Unix patterns for this line, including\r\nthe /usr/bin/env form.\r\nThe launcher’s #! parsing mechanism is applied when you run scripts from command\r\nlines with the py program, and when you click Python file icons (in which case py is run\r\nimplicitly by filename associations). Unlike Unix, you do not need to mark files with\r\nexecutable privileges for this to work on Windows, because filename associations achieve similar results.\r\nFor example, the first of the following is run by Python 3.X and the second by 2.X\r\n(without an explicit number, the launcher defaults to 2.X unless you set a PY_PYTHON\r\nenvironment variable):\r\nc:\\code> type robin3.py\r\n#!/usr/bin/python3\r\nprint('Run', 'away!...')\r\nc:\\code> py robin3.py\r\nRun away!...\r\nc:\\code> type robin2.py\r\n#!python2\r\nprint 'Run', 'away more!...'\r\nc:\\code> py robin2.py\r\nRun away more!...\r\n\r\n# 3.X function\r\n# Run file per #! line version\r\n\r\n# 2.X statement\r\n# Run file per #! line version\r\n\r\nThis works in addition to passing versions on command lines—we saw this briefly\r\nearlier for starting the interactive prompt, but it works the same when launching a script\r\nfile:\r\nc:\\code> py −3.1 robin3.py\r\nRun away!...\r\n\r\n# Run per command-line argument\r\n\r\nThe net effect is that the launcher allows Python versions to be specified on both a perfile and per-command basis, by using #! lines and command-line arguments, respec1. As we discussed when exploring command lines, all recent Windows versions also let you type just the\r\nname of a .py file at the system command line—they use the Registry to determine that the file should be\r\nopened with Python (e.g., typing brian.py is equivalent to typing python brian.py). This command-line\r\nmode is similar in spirit to the Unix #!, though it is system-wide on Windows, not per-file. It also requires\r\nan explicit .py extension: filename associations won’t work without it. Some programs may actually\r\ninterpret and use a first #! line on Windows much like on Unix (including Python 3.3’s Windows\r\nlauncher), but the system shell on Windows itself simply ignores it.\r\n\r\nUnix-Style Executable Scripts: #! | 61"}}]}}
